## 1로 만들기
## 정수 X가 주어졌을 때, 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지
# 1. X가 5로 나누어 떨어지면, 5로 나눔
# 2. X가 3으로 나누어 떨어지면, 3으로 나눔
# 3. X가 2로 나누어 떨어지면, 2로 나눔
# 4. X에서 1을 뺌
# 정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 값을 1로 만들고자 함 연산을 사용하는 횟수의 최솟값을 출력
# ex) 26 -> 25 -> 5 -> 1 => 3번 연산(-1 한 번, 5로 나누기 두 번)

## 내 답안
# x=int(input()) # x 값 입력 받기
# cnt = 0
# while x != 1:
#     if x % 5 == 0:
#         x /= 5
#     elif (x -1) % 5 == 0:
#         x -= 1
#         x /= 5
#         cnt+=1
#     elif x % 3 == 0:
#         x /= 3
#     elif (x -1) % 3 == 0:
#         x -= 1
#         x /= 3
#         cnt+=1
#     elif x % 2 == 0:
#         x /= 2
#     else:
#         x -= 1
#     cnt += 1

# print(cnt)

## 동빈나 답안
## 피보나치 수열 문제를 도식화한 것처럼 함수가 호출되는 과정을 그림으로 도식화 해보면 최적 부분 구조와 중복되는 부분 문제를 만족
## a[i] = i를 1로 만들기 위한 최소 연산 횟수
## a[i] = min(a[i-1], a[i/2], a[i/3], a[i/5]) + 1 => 한번 연산을 한 것 이므로 + 1을 해준다
## 단, 1을 빼는 연산을 제외하고는 해당 수로 나누어 떨어질 때에 한해 점화식을 적용할 수 있음

x=int(input()) # x 값 입력 받기
d=[0] * 30001 # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화

# 다이나믹 프로그래밍 진행(바텀업)
for i in range(2, x+1):
    # 아래 네 가지 경우에서 가장 작은 값으로 갱신
    d[i] = d[i - 1] + 1 # 현재의 수에서 1을 빼는 경우
    if i%2 == 0: # 현재의 수가 2로 나누어 떨어지는 경우
        d[i] = min(d[i], d[i // 2] + 1)
    if i%3 == 0: # 현재의 수가 3로 나누어 떨어지는 경우
        d[i] = min(d[i], d[i // 3] + 1)
    if i%5 == 0: # 현재의 수가 5로 나누어 떨어지는 경우
        d[i] = min(d[i], d[i // 5] + 1)
    
print(d[x])


