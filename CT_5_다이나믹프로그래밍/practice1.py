## 개미 전사
## 일직선으로 이어져 있는 여러 개의 식량창고가 있는데 각 식량창고에는 정해진 수의 식량을 저장하고 있으며
## 식량창고를 선택적으로 약탈하여 식량을 빼앗는데 일직선 상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챔
## 따라서 들키지 않고 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량 창고를 약탈해야 하는데
## 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램 작성

## 내 답안 => 1 0 1 4 이면 홀수, 짝수가 아니라 첫번째, 마지막을 더한게 최댓값 => 한 칸만 떨어지는게 아니라 한 칸 이상도 고려해야함 
# n = int(input())
# array = list(map(int, input().split()))

# osum=0
# esum=0

# for i in range(n):
#     if i % 2 == 1:
#         osum += array[i] 
#     else:
#         esum += array[i]

# if osum < esum:
#     print(esum)
# else:
#     print(osum)

## 동빈나 답안
## a0, a1, a2, a3, ... 들을 DP 테이블에 미리 저장해 놓으면 다이나믹 프로그래밍을 적용할 수 있음
## i 번째 최댓값은 i-1 번째와 i-2 번째의 최댓값에 i 번째 식량을 더해서 비교해 큰 값임
## a[i] = i번째 식량창고까지의 최적의 해(얻을 수 있는 식량의 최댓값)
## k[i] = i번째 식량창고에 있는 식량
## 점화식 => a[i] = max(a[i-1]), a[i-2] + k[i])
## 한 칸 이상 떨어진 식량 창고는 항상 털 수 있으므로 (i-3)번째 이하는 고려할 필요가 없음 

n = int(input()) # 정수 n을 입력 받기
array = list(map(int, input().split())) # 모든 식량 정보 입력 받기

d = [0] * 100 # 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화

# 다이나믹 프로그래밍 진행(바텀업)
d[0] = array[0]
d[1] = max(array[0], array[1])
for i in range(2, n):
    d[i]=max(d[i-1], d[i-2] + array[i])

# 계산된 결과 출력
print(d[n-1])